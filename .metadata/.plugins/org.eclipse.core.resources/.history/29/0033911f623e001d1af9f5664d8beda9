System wastett


Request req	:req(TYPE, LOAD)
Request reqFromApp		:reqFromApp (TYPE, LOAD)
Request whenLeave : whenLeave(MESS)
Request goToPos	: goToPos(POS)
Request goToIndoor	: goToIndoor(POS,LOAD)
Request goToHome : goToHome(POS)
Request step : step(TIME)
Request is_alarm : is_alarm(_)

Reply loadaccepted       : loadaccepted(TYPE, LOAD)
Reply loadrejected     : loadrejected(TYPE, LOAD)
Reply loadacceptedForApp       : loadacceptedForApp(TYPE, LOAD)
Reply loadrejectedForApp     : loadrejectedForApp(TYPE, LOAD)
Reply fineScarico : fineScarico(MESS)
Reply done : done(POS)
Reply alldone : alldone(POS)
Reply athome : athome(POS)
Reply stepdone : stepdone(V)
Reply stepfail : stepfail(DURATION, CAUSE)

Dispatch cmd : cmd(MOVE)
Dispatch ready : ready(MESS)
Dispatch info : info(MESS)
Dispatch stop : stop(_)
Dispatch alarm_on : alarm_on(_)
Dispatch alarm_off : alarm_off(_)
Dispatch end_app : end_app(_)
Dispatch start_app : start_app(_)

Event led_message : led_message(MESS)
Event alarm_active : alarm_active(_)
Event alarm_deactive : alarm_deactive(_) 
Event activate : activate(_)
Event deactivate : deactivate(_)

Context ctxbasicrobot  ip [host="127.0.0.1" port= 8020]
Context ctxwastett   ip [host="localhost" port=8040]
//Context ctxsonar_led ip [host="127.0.0.1" port=8065]  //Simulation
Context ctxsonar_led ip [host="192.168.43.83" port=8065]  //Raspberry

ExternalQActor basicrobot context ctxbasicrobot
ExternalQActor ledqak context ctxsonar_led
ExternalQActor sonar_rasp context ctxsonar_led

//--------------------------------------------- WASTE_SERVICE ------------------------------------------------------

QActor waste_service context ctxwastett{
	[#
		lateinit var Type : String
		lateinit var Load : String
		lateinit var Pos : String
		var Posizione : String = "Home"
		val MAXPB = 100
		val MAXGB = 15
		var currentPB : Double = 0.00
		var currentGB : Double = 0.00 
		lateinit var IsAccepted : String
		var is_sonar_active = false
	#]

//--------------------- Attivazione waste_service ---------------------	     			    				     	  
	State init initial{
		println("Waste service attivo")
		[#  
			println("Peso iniziale rifiuti in plastic box: " + currentPB);
			println("Peso iniziale rifiuti in glass box: " + currentGB);
			Posizione = "Home"
		#]
	}
	Transition t0  whenRequest req -> handleRequest
		
		
//--------------------- Il waste_service riceve le richieste da gestire e risponde con loadaccepted o loadrejected ---------------------	   
	State handleRequest {
		if[# !is_sonar_active #]{
			forward sonar_handler -m start_app : start_app
			[#is_sonar_active = true#]
		}
		printCurrentMessage 
		updateResource [#"trolleyPos($Posizione)"#]
	    onMsg(req: req(TYPE, LOAD)){
			[#
			   Type = payloadArg(0);
			   Load = payloadArg(1);
			#]  
		    if [#  Type == "PB" #]{
				[#
					Pos = "PlasticBox";
					var Peso = Load.toDouble();
				#]
            	if[# currentPB+Peso<=MAXPB#]{
                        [# currentPB = currentPB + Peso;
                        	println("Peso corrente PB:" + currentPB);
                        	IsAccepted = "true";
                        #]
                        replyTo req with loadaccepted : loadaccepted ($Type, $Load) 
					}
					else{
						[#  Pos = "Home"; 
							println("la richiesta e' stata rifiutata");
							IsAccepted = "false";
						#]
				        replyTo req with loadrejected : loadrejected ($Type, $Load)      
            }
           }
           if [#  Type == "GB" #]{
					[# Pos = "GlassBox";
						var Peso = Load.toDouble();	
					#] 
				
					if[# currentGB+Peso<=MAXGB#]{
                        	[# currentGB = currentGB + Peso;
                        		println("Peso corrente GB:" + currentGB);
                        		IsAccepted = "true";
              
                        	#]
                        	replyTo req with loadaccepted : loadaccepted ($Type, $Load)
					}
				else{
					[#  Pos = "Home";
						println("la richiesta e' stata rifiutata");
						IsAccepted = "false";						
					#] 
				    replyTo req with loadrejected : loadrejected ($Type, $Load)
					}
					}
            }
    }	
	    Transition t0 whenMsg ready -> handleanswer
    			  whenReply alldone -> handleanswer 
    			  whenReply athome -> handleanswer
    			  
//--------------------- Il waste_service invia una richiesta al transport_trolley dove gli comunica se recarsi ad indoor per caricare i nuovi rifiuti o tornare ad Home ---------------------	     			    
    State handleanswer{
    	if[#IsAccepted == "true"#]{
    		if[# Type == "GB" #]{
					[# Pos = "GlassBox";#]
			}
			else{
				[# Pos = "PlasticBox";#]
			}
    		request transport_trolley -m goToIndoor : goToIndoor($Pos, $Load)
    	}
    	else{
    		[# Pos = "Home";#] 
    		request transport_trolley -m goToHome : goToHome($Pos)
    	}
    }
    	Transition t0 whenReply done -> nextmove
    			  whenReply athome -> init
   
//--------------------- Il waste_service invia una richiesta al transport_trolley dove gli comunica la destinazione in cui deve recarsi e un messaggio al truck driver---------------------	     			    
    State nextmove{
    	[#Posizione = "Indoor"
    	  var Mess : String = "Indoor libera"
    	 #]
    	updateResource [# "trolleyPos($Posizione)" #]
  		forward truckapp_handler -m info :info($Mess)
  		delay 1000
  	
    	if [# Type == "PB" #]{
    		[#
    			Posizione = "PlasticBox";
    		 #]    		    
    		 request transport_trolley -m goToPos : goToPos($Posizione)	
    	}
    	if [#  Type == "GB" #] {
    		[# 
	    		Posizione = "GlassBox";
    		#]
    		request transport_trolley -m goToPos : goToPos($Posizione) 
    	}
    }
		Transition t1 whenRequest req -> handleRequest
				  whenReply alldone -> new_req
    
//--------------------- Il waste_service è in attesa di una nuova richiesta --------------------	     			    
	State new_req {
		updateResource [# "trolleyPos($Posizione)" #]
		updateResource [# "pesoPB($currentPB)" #]
		updateResource [# "pesoGB($currentGB)" #]
		println("Waiting new request...")
		delay 3000
	}
		Transition t1  whenRequest req -> handleRequest
				   whenMsg ready -> sendHome

//--------------------- Il waste_service invia al transport_trolley una richiesta di tornare ad Home ---------------------	     			    				     	  
	State sendHome{
		[# 
	    Posizione = "Home";
    	#]
    	request transport_trolley -m goToHome : goToHome($Posizione) 
	}
		Transition t2 whenReply athome -> end 

//--------------------- Fine Simulazione ---------------------	     			    				     	  

	State end{
		[#var Message : String = "End Simulation"
		 Posizione = "Home"
		 is_sonar_active = false
		#]
		updateResource [# "trolleyPos($Posizione)" #]
		forward sonar_handler -m end_app : end_app
	}	
	Goto init
}

//----------------------------------------- TRANSPORT_TROLLEY--------------------------------------------------

QActor transport_trolley context ctxwastett{ 
	 [# 
	 	var Posizione : String = "Home";
	 	lateinit var Dest : String;
	 	var Peso = 0L;
	 	var Time = 0L;
	 	var stepH : Int = 0;
	 	var stepB : Int = 0;
	 	var numStep : Int = 0;
	 	lateinit var Message : String;
	 	lateinit var lato : String;
	 	lateinit var Led_s : String;
	 #] 

//--------------------- Attivazione transport_trolley ---------------------	         				     	  
	 State init initial { 
	 	discardMsg Off 
		println("Transport trolley attivo")
		[#Message= "ready"
			Led_s = "Off"#
		]
		updateResource [# "ledStatus(off)" #]
		emit led_message : led_message($Led_s)	
		forward waste_service -m ready : ready($Message)
	} 
		Transition t0   whenMsg alarm_on -> handleEvent
					whenRequest goToIndoor -> indoor 
	        		whenRequest goToPos -> moving 
	       			whenRequest goToHome -> home

//--------------------- Il transport_trolley riceve una richiesta dal waste_service e si reca ad Indoor ---------------------	     			    	  
	State indoor{ 
	 	onMsg(goToIndoor : goToIndoor (POS,LOAD)){
	 		[# Peso = payloadArg(1).toLong() #]
	 	}
	 	  [# Dest = "Indoor" #]
	 	  updateResource [# "ledStatus(blink)" #]		
		  if [# Posizione == "PlasticBox" #] { 
		  		[#Led_s = "Blink"#] 
			  	forward basicrobot -m cmd : cmd(l)
				delay 340
				emit led_message : led_message($Led_s)	
			   	request basicrobot -m step : step(340)
		  }
		  if [# Posizione == "GlassBox" #] {
		  		[#Led_s = "Blink"#] 
		  		emit led_message : led_message($Led_s)	
			  	request basicrobot -m step : step(340)
		  }  
		  if [# Posizione == "Home" #] { 
		  		[#Led_s = "Blink"#] 
		  		request basicrobot -m step : step(340)
		  		emit led_message : led_message($Led_s)	
		  }
		  } 
		  	Transition t0 whenMsg alarm_on -> handleEvent
				   	  whenReply stepdone -> newmove 
				   	  whenReply stepfail -> aggiornapos

//--------------------- Il transport_trolley effettua una nuova mossa ed emette un evento al ledqak ---------------------	     			    	  	       		  
	State newmove{
			[#Led_s = "Blink"#] 
			request basicrobot -m step : step(340)
	   		emit led_message : led_message($Led_s)	
	   		updateResource [# "ledStatus(blink)" #]
	   		
	   }
	  	Transition t0  whenMsg alarm_on -> handleEvent
				   	  whenReply stepdone -> newmove 
				   	  whenReply stepfail -> aggiornapos
				  	

//--------------------- Il transport_trolley è arrivato a destinazione ed aggiorna la sua posizione ---------------------	     			    	  	       		         	  
	State aggiornapos{
	          [#
	          	Time = 1000*Peso 
	          	println("Time:" + Time)
	          	Led_s = "On" 
	          #]
	          emit led_message : led_message($Led_s)	
	          updateResource [# "ledStatus(on)" #]
	         
	          if[# Dest == "Indoor"#]{
	              if[#Posizione == "Home"#]{
	                 [# Posizione = "Indoor"; #]
	                  forward basicrobot -m cmd : cmd(l)
	                  delay 340
	                  println("Carico rifiuti ad Indoor")
	                  delayVar Time
	                  replyTo goToIndoor with done : done($Posizione)	
	              }
	              else{
	              	if[#Posizione == "PlasticBox"#]{
		                  [# Posizione = "Indoor"; #]   
		                  forward basicrobot -m cmd : cmd(l)
		                  delay 340
		                  forward basicrobot -m cmd : cmd(l)
		                  delay 340
		                  println("Carico rifiuti ad Indoor")
		                  delayVar Time 
		                  replyTo goToIndoor with done : done($Posizione)    
	              }
	              	if[#Posizione == "GlassBox"#]{
		              	  [# Posizione = "Home"; #]
		                  forward basicrobot -m cmd : cmd(l)
		                  delay 340
		                  request basicrobot -m step : step (340) 
	              	}
	              }
	          }
	          
	          if[#Dest == "PlasticBox"#]{
	          		[#Posizione = "PlasticBox"
	          		  println("Sto scaricando rifiuti a " + Posizione) 
	          		 #]
	          		delayVar Time
	          		forward basicrobot -m cmd : cmd(l)
	          		delay 340
	                replyTo goToPos with alldone : alldone($Posizione) 
	                forward waste_service -m ready : ready($Message)
	              } 
	           
	           if[#Dest == "GlassBox"#]{
	           	if[#Posizione == "Indoor"#]{
	           		[#Posizione = "PlasticBox"#]
	           		forward basicrobot -m cmd : cmd(l)
	                delay 340
	                request basicrobot -m step : step (340) 
	           	}else{
	           		[#Posizione = "GlassBox"
	           		  println("Sto scaricando rifiuti a " + Posizione)
	           		 #]
	           		delayVar Time 
	           		forward basicrobot -m cmd : cmd(l)
	           		delay 340
	                replyTo goToPos with alldone : alldone($Posizione) 
	                forward waste_service -m ready : ready($Message)
	           	}
	          }  
	              
	          if[#Dest == "Home"#]{
	          	 if[#Posizione == "PlasticBox"#]{
	                 [# Posizione = "GlassBox"; #]  
	                  forward basicrobot -m cmd : cmd(l)
	                  delay 340
	                  request basicrobot -m step : step (340) 
	              }
	              else{
	                  [# Posizione = "Home" 
	                  	Led_s = "Off"#]            
	                  println("Sono tornato ad home")
	                  forward basicrobot -m cmd : cmd(l)
	                  delay 340
	                  emit led_message : led_message($Led_s)	 
			  		  updateResource [# "ledStatus(off)" #]      
	                  replyTo goToHome with athome : athome($Posizione) 
	                  forward waste_service -m ready : ready($Message)
	              }
	          }
	      }
			Transition t0 whenMsg alarm_on -> handleEvent 
	  				 whenReply stepdone -> newmove 
				   	 whenReply stepfail -> aggiornapos
	   				 whenRequest goToIndoor -> indoor 
	        	     whenRequest goToPos -> moving 
	       		     whenRequest goToHome -> home 
	       		    
	State moving{ 
		onMsg(goToPos : goToPos(POS)){ 
		   [# 
		   	Dest = payloadArg(0)
		   	println(Posizione)
		    Led_s = "blink"
		   #]
	       emit led_message : led_message($Led_s)	
	       updateResource [# "ledStatus(on)" #]
		   request basicrobot -m step : step (340)
	  }
	 } 
	  Transition t0 whenMsg alarm_on -> handleEvent
				   	whenReply stepdone -> newmove 
				   	whenReply stepfail -> aggiornapos
	 				whenRequest goToIndoor -> indoor 
	        		whenRequest goToPos -> moving 
	       			whenRequest goToHome -> home 

//--------------------- Il transport_trolley è a Home ed emette un evento al ledqak  per farlo spegnere ---------------------         
	 State home{
	  	[# Dest = "Home" #]
	  	if[# Posizione == "Home" #]{
	  		[#Led_s = "Off"#]
			emit led_message : led_message($Led_s)	 
			updateResource [# "ledStatus(off)" #]   
	  		replyTo goToHome with athome : athome($Posizione)
	  		forward waste_service -m ready : ready($Message)
	  	}
	  	else{
			request basicrobot -m step : step (340)
		 }
	  }
		 Transition t0  whenMsg alarm_on -> handleEvent
				   	whenReply stepdone -> newmove 
				   	whenReply stepfail -> aggiornapos
				  	whenRequest goToIndoor -> indoor 
	        		whenRequest goToPos -> moving 
	       			whenRequest goToHome -> home 	
	       			
	
//--------------------- Gestione eventi emessi dal sonar del Raspberry Pi o simulati ---------------------
//---------------------  il transport_trolley ferma il basicrobot fintanto che l'ostacolo non viene rimosso ---------------------
	State handleEvent{
		println("Ostacolo rilevato")
		updateResource [#"StateTT(STOP)" #]   
		forward basicrobot -m cmd : cmd(h)
		delay 340
		if[#Posizione == Dest#]{
			forward transport_trolley -m stop : stop(_)
		}
		[#Led_s = "On"#]
 		emit led_message : led_message($Led_s)	 
		updateResource [# "ledStatus(on)" #]      
	} 
	Transition t0 whenReply stepdone -> movingObstacle
				  whenReply stepfail -> movingObstacle
				  whenMsg stop -> standObstacle
	

	State movingObstacle{
		println("Attendere rimozione dell'ostacolo")
	}
	Transition t0 whenMsg alarm_off -> newmove
	

	State standObstacle{
		println("Attendere rimozione dell'ostacolo")
	}
	Transition t0 whenMsg alarm_off -> continua
	
	
	State continua{
		println("Ostacolo rimosso")
	}
	Transition t0  whenMsg alarm_on -> handleEvent
				   whenRequest goToIndoor -> indoor 
	        	   whenRequest goToPos -> moving 
	       		   whenRequest goToHome -> home 
}


//--------------------------------------------- TRUCKAPP_HANDLER ------------------------------------------------------
QActor truckapp_handler context ctxwastett{
	[#
		lateinit var TYPE : String;
		lateinit var LOAD : String;
		lateinit var Mess : String;
	#]
	State init initial{
		println("Track driver: attivo")
	}
	Transition t0 whenRequest reqFromApp -> sendReq

//--------------------- La truckapp invia una richiesta alla truckapp_handler e questa la inoltra al waste_service ---------------------
	
	State sendReq{
		onMsg(reqFromApp:reqFromApp(TYPE, LOAD)){
			[#
				 TYPE = payloadArg(0);
				 LOAD = payloadArg(1);
			#]
		}
		request waste_service -m req : req($TYPE, $LOAD) 
	}
	Transition t1 whenReply loadaccepted -> replyAccepted
				  whenReply loadrejected -> replyRejected

//--------------------- La truckapp_handler risponde alla richiesta della truckapp confermando la possibilità di prendere il carico di rifiuti  ---------------------				  
	State replyAccepted{
		println("Richiesta accettata, attendere...")
		replyTo reqFromApp with loadacceptedForApp : loadacceptedForApp($TYPE, $LOAD)
	}
	Transition t2 whenRequest whenLeave -> leave

		  		
	State leave{
		println("Scarico terminato, si prega di lasciare l'area di indoor")
		[#Mess = "Indoor libera"#]
	}
	Transition t1 whenMsg info -> sendAnswer
	
	
	State sendAnswer{
		replyTo whenLeave with fineScarico : fineScarico($Mess)
	}
	Goto init

//--------------------- La truckapp_handler risponde in modo negativo alla richiesta della truckapp ---------------------				  	
	State replyRejected{
		println("Impossibile accettare la richiesta, si prega di lasciare l'area")
		replyTo reqFromApp with loadrejectedForApp : loadrejectedForApp($TYPE, $LOAD)
	}
	Transition t2 whenRequest whenLeave -> sendAnswer
 }
 
 
 //----------------------------------------- SONAR_HANDLER --------------------------------------------------
 
 QActor sonar_handler context ctxwastett{
 	
 	State init initial{
 		println("Attivare sonar")
 	}
 	Transition t0 whenMsg start_app -> activateSonar

//--------------------- Viene emesso un evento per comunica al sonar di attivarsi ---------------------				  	 	
 	State activateSonar{
 		emit activate : activate(_)
 		updateResource [# "sonar_handler(activate)" #]		
 		
 	}
 	Transition t0 whenMsg end_app -> deactivateSonar
 				  whenEvent alarm_active -> sendAlarmOn
 				  whenEvent alarm_deactive -> sendAlarmOff
 				  whenMsg start_app -> activateSonar
 
 //--------------------- Si comunica al transport_trolley la presenza di un ostacolo dinamico ---------------------				  	 					
 	State sendAlarmOn{
 		updateResource [# "sonar_handler(allarm_on)" #]		 		
 		forward transport_trolley -m alarm_on : alarm_on(_)
 	}
 	Transition t0 whenMsg end_app -> deactivateSonar
 				  whenEvent alarm_active -> sendAlarmOn
 				  whenEvent alarm_deactive -> sendAlarmOff
 				  whenMsg start_app -> activateSonar
 			
//--------------------- Si comunica al transport_trolley che l'ostacolo è stato rimosso ---------------------				  	 					
	State sendAlarmOff{
 		forward transport_trolley -m alarm_off : alarm_off(_)
 		updateResource [# "sonar_handler(allarm_off)" #]		
 	}
 	Transition t0 whenMsg end_app -> deactivateSonar
 				  whenEvent alarm_active -> sendAlarmOn
 				  whenEvent alarm_deactive -> sendAlarmOff
 				  whenMsg start_app -> activateSonar
 				
//--------------------- Viene emesso un evento per comunica al sonar di disattivarsi ---------------------				  	 					
 	State deactivateSonar{
 		emit deactivate : deactivate(_)
 		updateResource [# "sonar_handler(deactivate)" #]		
 	}
 	Transition t0 whenMsg start_app -> activateSonar
 }