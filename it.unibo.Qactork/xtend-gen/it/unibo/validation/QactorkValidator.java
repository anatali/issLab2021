/**
 * generated by Xtext 2.16.0
 */
package it.unibo.validation;

import it.unibo.qactork.Context;
import it.unibo.qactork.EmptyTransition;
import it.unibo.qactork.Message;
import it.unibo.qactork.NonEmptyTransition;
import it.unibo.qactork.PHead;
import it.unibo.qactork.PStruct;
import it.unibo.qactork.QActor;
import it.unibo.qactork.QActorExternal;
import it.unibo.qactork.QActorSystemSpec;
import it.unibo.validation.AbstractQactorkValidator;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class QactorkValidator extends AbstractQactorkValidator {
  /**
   * Only one initial plan is allowed
   */
  @Check
  public void checkSingleNormalPlan(final QActor qactor) {
    final Function1<it.unibo.qactork.State, Boolean> _function = (it.unibo.qactork.State it) -> {
      return Boolean.valueOf(it.isNormal());
    };
    int _size = IteratorExtensions.size(IteratorExtensions.<it.unibo.qactork.State>filter(qactor.getStates().iterator(), _function));
    boolean _equals = (_size == 0);
    if (_equals) {
      this.error("A initial state is required", null);
    }
    final Function1<it.unibo.qactork.State, Boolean> _function_1 = (it.unibo.qactork.State it) -> {
      return Boolean.valueOf(it.isNormal());
    };
    int _size_1 = IteratorExtensions.size(IteratorExtensions.<it.unibo.qactork.State>filter(qactor.getStates().iterator(), _function_1));
    boolean _greaterThan = (_size_1 > 1);
    if (_greaterThan) {
      this.error("Only one initial state is allowed", null);
    }
  }
  
  /**
   * System name must be lowercase
   */
  @Check
  public void systemName(final QActorSystemSpec sys) {
    boolean _equals = sys.getName().toLowerCase().equals(sys.getName());
    boolean _not = (!_equals);
    if (_not) {
      this.error("Uppercase letters not allowed for system name", null);
    }
  }
  
  /**
   * Actor names must be lowercase
   */
  @Check
  public void actorName(final QActor qa) {
    boolean _equals = qa.getName().toLowerCase().equals(qa.getName());
    boolean _not = (!_equals);
    if (_not) {
      this.error("Uppercase letters not allowed in actor\'s names", null);
    }
  }
  
  public void actorName(final QActorExternal qa) {
    boolean _equals = qa.getName().toLowerCase().equals(qa.getName());
    boolean _not = (!_equals);
    if (_not) {
      this.error("Uppercase letters not allowed in actor\'s names", null);
    }
  }
  
  /**
   * Context names must start with a lowercase
   */
  @Check
  public void ctxName(final Context ctx) {
    char _charAt = ctx.getName().toLowerCase().charAt(0);
    char _charAt_1 = ctx.getName().charAt(0);
    boolean _equals = (_charAt == _charAt_1);
    boolean _not = (!_equals);
    if (_not) {
      this.error("Context name must start with a lowercase ", null);
    }
    boolean _startsWith = ctx.getName().startsWith("ctx");
    boolean _not_1 = (!_startsWith);
    if (_not_1) {
      this.warning("Context name should start with ctx", null);
    }
  }
  
  /**
   * Event payload must be  a Struct
   */
  @Check
  public void eventPayload(final Message ev) {
    PHead _msg = ev.getMsg();
    boolean _not = (!(_msg instanceof PStruct));
    if (_not) {
      this.error("msg payload must be a Struct", null);
    }
  }
  
  @Check
  public void emptyAfterTransition(final NonEmptyTransition t) {
    EmptyTransition _elseempty = t.getElseempty();
    boolean _tripleNotEquals = (_elseempty != null);
    if (_tripleNotEquals) {
      this.error("AVOID else clause: not yet implemented", null);
    }
  }
}
