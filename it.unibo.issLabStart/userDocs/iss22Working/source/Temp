in anaconda 
lsvirtualenv -l
sphinks-quickstart  //TUTTO ATTACCATO

.. _test di Turing : https://it.wikipedia.org/wiki/Test_di_Turing

:remark:`
.. epigraph:: 

.. _tcpsupprt:

.. list-table:: 
  :widths: 50,50
  :width: 100%

  * - a1
    - a2
  * - b1
    - b2

``  ``

:doc:`RadarGuiCoap`

.. _My target:

`My target`_.

:ref:`SonarModel<SonarModel>`

===
---
+++
%%%
&&&

:emphasize-lines: 8,10,16



.. Mettte le immagini fianco a fianco
.. .. image:: ./_static/img/rasp/Raspberry-Pi-GPIO-Layout-Model-B-Plus.png
..   :width: 20%
.. .. image:: ./_static/img/rasp/Raspberry-Pi-GPIO-Layout-Model-B-Plus.png
..   :width: 20%   ``





 Il delay qualificato cone **'HORRIBLE EFFECT'**  potrebbe ripercuotersi sui client 
in modo inaccettabile e mettere in crisi un sistema. Si veda ad esempio


.. _HorribleEffetcts:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Sperimentazione di effetti indesiderati
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Gli effetti dei ritardi indotti dagli observer POJO possono essere sperimentati invocando, ad esempio,
``SonarUsageMainWithContextTcp`` dopo avere tolto il commento sul delay nel metodo update di
 `SonarObserverFortesting`_.


==================================================
Il concetto di contesto
==================================================

.. include:: ContextServer.rst 

==================================================
Da TCP a CoAP
==================================================

.. include:: DaTcpACoAP.rst 


==================================================
WebSockets
==================================================

.. include:: WebSockets.rst 



==================================
Distribuzione del RadarSystem
==================================  

.. include:: RadarSystemDeploy.rst  

Il metodo ``elaborate`` con argomento :ref:`ApplMessage<ApplMessage>` viene presentato subito qui,
ma verrà introdotto solo più avanti
(si veda :ref:`IApplMsgHandler<IApplMsgHandlerEsteso>` in :doc:`ContestiContenitori`) quando avremo la necessità di 
introdurre nei messaggi anche informazioni relative al nome del mittente e del destinatario.



===========================   ===========================    =========================== 
     Server                              id                        entry
---------------------------   ---------------------------   ---------------------------
:ref:`TcpContextServer`               nome host                 port
:ref:`MqttContextServer`              id del client              nome topic     
:ref:`CoapContextServer`                    -                      -
===========================   ===========================    ===========================   

.. list-table:: 
  :widths: 50,50
  :width: 100%
  
  * - Il committente fornisce software relativo al Led ?
    - Si, ``led25GpioTurnOn.sh`` e ``led25GpioTurnOff.sh`` (progetto *it.unibo.rasp2021*)

 
.. Test funzionale
.. Si veda :doc:`ContextServer`.

La distribuzione del *RadarSystem* assume due forme:

- la forma di una libreria di nome ``it.unibo.enablerCleanArch-1.0.jar`` prodotta dal progetto it.unibo.enablerCleanArch_
- la forma di una applicazione web (che utiliza la libreria precedente) prodotta dal progetto ``it.unibo.msenabler``


.. _enablerCleanArch:

Alcune webcam hanno la funzione di bilanciare automaticamente la loro luminosità. 
Ad esempio, in una stanza buia percepiscono che la luminosità deve essere aumentata mentre in un'area luminosa, 
la luminosità potrebbe dover essere ridotta. 
La fotocamera lo fa esaminando i propri fotogrammi e analizzandoli.
Quando si verifica una cattura di un'immagine subito dopo l'inizializzazione della fotocamera, 
non ha visto dati sufficienti per sapere quanto sia luminoso l'ambiente e sembra che presuppone 
che l'ambiente sia SUPER luminoso e riduce al minimo il controllo dell'esposizione (risultando in un'immagine nera). 
Man mano che vengono esaminati più fotogrammi, la fotocamera regola rapidamente le impostazioni di esposizione.

Per utilizzare fswebcam, possiamo fornirgli l'opzione la -S <num>cui opzione è il numero di fotogrammi 
che la fotocamera dovrebbe "vedere" e "saltare" prima di acquisire l'immagine desiderata. 
Trovo che se fornisco un salto della 20fotocamera ha avuto abbastanza fotogrammi per regolare automaticamente 
la sua esposizione e poiché stiamo elaborando 30 fotogrammi al secondo, 
è ancora meno di un secondo di ritardo per catturare 1 fotogramma. 
Per lo streaming video, non dovremmo avere il problema in quanto la fotocamera verrà inizializzata 
e rimarrà inizializzata.




 

 --------------------------------------
demoStrange.qak
--------------------------------------

  
  
.. list-table:: 
  :widths: 30,70
  :width: 100%

  * -  
      .. image::  ./_static/img/Qak/demostrange.png
         :align: center 
         :width: 100% 
    -  
      .. code::
          
        System  demostrange
        Dispatch cmd : cmd(X) 

        Context ctxdemostrange ip [host="localhost" port=8055]

        QActor demostrange context ctxdemostrange{
          State s0 initial { 	 
            printCurrentMessage
            forward demostrange -m cmd : cmd(a)
          }   
          Goto s1             
          State s1{
            printCurrentMessage  
            forward demostrange -m cmd : cmd(b) 
          }
          Goto s2            
          State s2{
            printCurrentMessage
          }
          Transition t0 whenTime 10 -> s3
                        whenMsg cmd -> s2  
          State s3{
            printCurrentMessage
            println("demostrange | s3, BYE")            
          }
        }

Questo esempio evidenzia che:

 - una empty-move è realizzata con emissione di un evento ``local_noMsg`` 
 - una empty-move non crea indicazioni sui messaggi da elaborare: i messaggi in arrivo 
   (inviati dall'attore stesso come auto-messaggi) sono memorizzati
   nella coda interna locale e vengono gestiti nello stato ``s2``
 - un attore non deve rimanare in attesa perenne di messaggi, in quanto può fare una empty-move 
   dopo un certo tempo (**timeOut**) 
 - lo scadere del *timeOut* provoca l'emissione di un evento di indentificatore univoco 
   ``local_tout_aaa_sss`` ove ``aaa`` è il nome dell'attore e ``sss`` è  il nome dello stato corrente

 
:blue:`Output`
 

.. code::

  demostrange in s0 | msg(autoStartSysMsg,dispatch,demostrange,demostrange,start,5)
  demostrange in s1 | msg(local_noMsg,event,demostrange,none,noMsg,4)
  demostrange in s2 | msg(local_noMsg,event,demostrange,none,noMsg,4)
  demostrange in s2 | msg(cmd,dispatch,demostrange,demostrange,cmd(a),6)
  demostrange in s2 | msg(cmd,dispatch,demostrange,demostrange,cmd(b),7)
  demostrange in s3 | msg(local_tout_demostrange_s2,event,timer,none,local_tout_demostrange_s2,8)
  demostrange | s3, BYE


 

------------------------------------------------ 
IssWsHttpKotlinSupport
------------------------------------------------      

library: **IssActorKotlinRobotSupport-2.0.jar**

- `wssupportAsActorKotlin`_
- `RobotService`_
- `BasicStepRobotService`_
- `ActorWithKotlinSupport`_

The class ``IssWsHttpKotlinSupport.kt`` provides a singleton (for each ip address) 
that defines utility operations to connect/disconnect (to the given ip address) 
via HTTP or a websocket, using the library okhttp3.

This utility:

- implements the interface IssCommSupport.kt
- implements the operations defined in the interface IssOperations.kt
- works as an observer of the ws-socket
- is, in its turn, observable by components that implement the interface ``IUniboActor.kt``
  
  Progetto: **it.unibo.kotlinSupports** dir: *app\src\main\kotlin\* package: *it.unibo.interaction*

  .. code:: Java
        
    interface IUniboActor : IssActorObservable  {
        fun myname() : String
        fun send(msg: String )
    }

      
    interface IssActorObservable {
        fun registerActor(obs: IUniboActor)
        fun removeActor(obs: IUniboActor)
    }

    interface IUniboActor : IssActorObservable  {
        fun myname() : String
        fun send(msg: String )
    }



    StartUp
Scarica Eclipse Xtext e installa il plug-in Eclipse per Kotlin.

Imposta (tramite Windows->Preferences )
il compilatore Java alla versione 1.8 e il jre a jre1.8.0_ ...

Copia nella directory dropins di Eclipse i file che costituiscono il supporto al metamodello-qak:
it.unibo.Qactork_1.2.5.jar, it.unibo.Qactork.ui_1.2.5.jar, it.unibo.Qactork.ide_1.2.5.jar.

Creazione di un nuovo progetto
In un’area di lavoro vuota, crea un nuovo progetto Java

Copiare il gradle build file build2022.gradle

Eseguire

gradle  -b build2022.gradle eclipse
In src , crea un file con estensione qak A questo punto Eclipse dovrebbe presentare una finestra come la seguente:

_images/qakStarting.png
Aggiungere la natura Kotlin al progetto

Per modificarli, usare comandi simili a :ref:`Modificare la scena nella immagine`. Ad esempio:

.. code::

  docker-compose -f basicrobot22.yaml run --service-ports robot /bin/sh
  docker ps -a 
  docker commit  CONTAINERID

  docker cp mystepTimeConfig.json faf69252ca5b:/unibobasicrobot22_robot_1/stepTimeConfig.json  ///it.unibo.basicrobot-1.0/bin
