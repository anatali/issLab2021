.. role:: red 
.. role:: blue 
.. role:: remark
.. role:: worktodo

===============================
Eventi
===============================

Concettualmente, una sorgente dovrebbe essere capace di 
emettere informazione percettibile da un numero qualsiasi di osservatori interessati,
senza che l'azione di osservazione possa alterare il funzionamento della sorgente.

Questa idea (che segnala un **abstraction gap**) 
suggerisce il concetto di *messaggio che non ha un preciso destinatario*
come indicato in :ref:`Terminologia di riferimento`.


:remark:`un attore può emette informazione in forma di evento`
 
Per implementare questa idea di evento, dobbiamo:

- dichiarare l'interesse da parte di un attore di percepire un evento ``Ev``;
- dotare 'geneticamente' un attore di una operazione ``emit`` che produce come effetto la inserzione 
  di ``Ev`` nella coda di tutti gli attori interessati, locali e remoti.

Come supporto alla realizzazione, useremo un attore specializzato.

-----------------------------------
EventMsgHandler
-----------------------------------

Un attore che ha due compiti principali

#. :blue:`registrazione`: tenere memoria del fatto che un attore  si è dichiarato interessato 
   alla percezione di un evento ``Ev``;
#. :blue:`aggiornamento`: inserire l'evento ``Ev`` nella coda di tutti gli attori interessati 
   quando un attore emette l'evento ``Ev``.

L'operazione ``emit`` di un evento ``Ev`` viene implementata 'ridirigendo' ``Ev`` a ``EventMsgHandler`` 
che a sua volta esegue l'operazione di :blue:`aggiornamento`.

L'operazione di aggiornamento viene realizzata usando l'operazione :ref:`Qak22Util.sendMsgToDest`  
per inviare il messaggio a tutti gli attori registrati.

-----------------------------------
Qak22Util.sendMsgToDest
-----------------------------------

.. code:: Java

    public static void sendMsgToDest(IApplMessage msg, String destActorName){
        QakActor22 dest = Qak22Context.getActor(destActorName);  
        if( dest != null ) { //attore locale
            dest.queueMsg(msg);
        }else{ //cerco proxy in proxyMap
            ProxyAsClient pxy  = Qak22Context.getProxy(destActorName);
            if( pxy == null ) {
                ColorsOut.outerr("Perhaps no setActorAsRemote for " + destActorName );
                return;
            }
            pxy.sendMsgOnConnection( msg.toString()) ; //NON Attende risposta  
        }
    }


La :blue:`registrazione` dell'interesse di un attore per un evento viene realizzata 
da una operazione di Qak22Context.

----------------------------------------
Qak22Context.registerAsEventObserver
----------------------------------------

.. code:: Java

    public class Qak22Context { 
        ...
        public static final String registerForEvent   = "registerForEvent";
        public static final String unregisterForEvent = "unregisterForEvent";

        public static void registerAsEventObserver(String observer, String evId) {
            QakActor22 a = getActor(EventMsgHandler.myName);
            if( a == null ) new EventMsgHandler();
            IApplMessage m = CommUtils.buildDispatch(observer,
                                registerForEvent, evId, EventMsgHandler.myName);
            Qak22Util.sendAMsg( m, EventMsgHandler.myName ); 
        }

    }

------------------------------
gestione di un evento
------------------------------

La gestione di un evento 

.. code:: Java
  
  protected static HashMap<String,String> eventObserverMap = new HashMap<String,String>();  

  protected void handleEvent(IApplMessage msg) {
    try {
    if( msg.msgId().equals(Qak22Context.registerForEvent)) {
      eventObserverMap.put(msg.msgSender(), msg.msgContent());
    }else if( msg.isEvent()) {
      eventObserverMap.forEach( ( actorName,  evName) -> {
            if( evName.equals(msg.msgId()) ) {
              sendMsg( msg  );
            }
      } ) ;
    }else ColorsOut.outerr( "QakActor22 handleEvent: msg unknown");
		}catch( Exception e) {...	}
	}    


  -------------------------------
Esempio: ``SonarActor22``
-------------------------------

L'attore ``SonarActor22`` NON riusa gli oggetti del dominio ma ridefinisce il componente come 
proattivo e reattivo, in modo simulato o meno.

In quanto ente proattivo, il ``SonarActor22`` emette eventi di distanza-misurata della forma

  ``msg(distance,event,sonar,observer,D,N)``


.. code:: Java

  public class SonarActor22 extends QakActor22{
  private IDistance curVal ;	

    protected void setup() {
      if( ! DomainSystemConfig.simulation )  { ... }
    else curVal = new Distance(90);		
    }
  	@Override
    protected void handleMsg(IApplMessage msg) {
      if( msg.isRequest() ) elabRequest(msg);
      else elabCmd(msg);
	  }

+++++++++++++++++++++++++++++++++
SonarActor22: Parte reattiva    
+++++++++++++++++++++++++++++++++

La parte reattiva consiste nella eleborazione dei comandi di attivazione/deattivazione e di richieste
sul valore corrente della distanza.

.. code:: Java

    protected void elabCmd(IApplMessage msg) {
    String msgCmd = msg.msgContent();
      switch( msgCmd ) {
      case ApplData.cmdActivate  : sonarActivate();  break;
      case ApplData.cmdDectivate : sonarDeactivate();break;
      default: ColorsOut.outerr(getName()  + " | unknown " + msgCmd);
    }

    protected void elabRequest(IApplMessage msg) { ... }

    protected void sonarActivate() {
      if( DomainSystemConfig.simulation ) sonarStepAsMock();
      else sonarStepAsConcrete();
    }    
    ...

+++++++++++++++++++++++++++++++++
SonarActor22: Parte proattiva    
+++++++++++++++++++++++++++++++++   

La parte proattiva  consiste nella continua rilevazione della distanza e nella emissione di eventi.

.. code:: Java

    protected void sonarStepAsMock() {		
      int v = curVal.getVal() - delta;
      updateDistance( v );		
      if( v > 0 && ! stopped) {
        CommUtils.delay( DomainSystemConfig.sonarDelay );
        autoMsg(ApplData.activateSonar);   
    }

    protected void sonarStepAsConcrete() { ... }


+++++++++++++++++++++++++++++++++
Emissione di eventi    
+++++++++++++++++++++++++++++++++ 

Il metodo ``updateDistance`` provvede ad emettere eventi che rendoo osservabile la distanza rilevata.

.. code:: Java

  protected void updateDistance( int d ) {
    curVal = new Distance( d );
    if( RadarSystemConfig.sonarObservable ) {
      IApplMessage distanceEvent = 
           Qak22Util.buildEvent(getName(), ApplData.evDistance, ""+d );
      emit(distanceEvent);
    }	
	}	
 
+++++++++++++++++++++++++++++++++
Configurazione lato Raspberry   
+++++++++++++++++++++++++++++++++ 

.. code:: Java

  @ActorLocal(
      name =      {"led", "sonar"  }, 
      implement = { LedActor.class,  SonarActor22.class }
  )
  @ActorRemote(name =   {"controller" },    
      host=    { ApplData.pcAddr }, 
      port=    { ""+ApplData.ctxPcPort }, 
      protocol={ "TCP"   }
  )
  public class DeviceActorsOnRasp {
    ...
  }


+++++++++++++++++++++++++++++++++
Configurazione lato PC   
+++++++++++++++++++++++++++++++++ 

.. code:: Java

  @ActorLocal(name =     {"controller" }, 
            implement = {unibo.radarSystem22.actors.ControllerActor.class })
  @ActorRemote(name =   {"led","sonar"}, 
              host=    {ApplData.raspAddr, ApplData.raspAddr}, 
              port=    { ""+ApplData.ctxRaspPort, ""+ApplData.ctxRaspPort}, 
              protocol={ "TCP" , "TCP" })
  public class ControllerActorOnPc {
    ...
  }