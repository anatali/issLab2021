.. role:: red 
.. role:: blue 
.. role:: remark
.. role:: worktodo

===============================
Eventi
===============================

Concettualmente, una sorgente dovrebbe essere capace di 
emettere informazione percettibile da un numero qualsiasi di osservatori interessati,
senza che l'azione di osservazione possa alterare il funzionamento della sorgente.

Questa idea (che segnala un **abstraction gap**) 
suggerisce il concetto di *messaggio che non ha un preciso destinatario*
come indicato in :ref:`Terminologia di riferimento`.


:remark:`un attore può emette informazione in forma di evento`
 
Per implementare questa idea di evento, dobbiamo:

- dichiarare l'interesse da parte di un attore di percepire un evento ``Ev``;
- dotare 'geneticamente' un attore di una operazione ``emit`` che produce come effetto la inserzione 
  di ``Ev`` nella coda di tutti gli attori interessati, locali e remoti.

Come supporto alla realizzazione, useremo un attore specializzato.

-----------------------------------
EventMsgHandler
-----------------------------------

Un attore che ha due compiti principali

#. :blue:`registrazione`: tenere memoria del fatto che un attore  si è dichiarato interessato 
   alla percezione di un evento ``Ev``;
#. :blue:`aggiornamento`: inserire l'evento ``Ev`` nella coda di tutti gli attori interessati 
   quando un attore emette l'evento ``Ev``.

L'operazione ``emit`` di un evento ``Ev`` viene implementata 'ridirigendo' ``Ev`` a ``EventMsgHandler`` 
che a sua volta esegue l'operazione di :blue:`aggiornamento`.

L'operazione di aggiornamento viene realizzata usando l'operazione :ref:`Qak22Util.sendMsgToDest`  
per inviare il messaggio a tutti gli attori registrati.

-----------------------------------
Qak22Util.sendMsgToDest
-----------------------------------

.. code:: Java

    public static void sendMsgToDest(IApplMessage msg, String destActorName){
        QakActor22 dest = Qak22Context.getActor(destActorName);  
        if( dest != null ) { //attore locale
            dest.queueMsg(msg);
        }else{ //cerco proxy in proxyMap
            ProxyAsClient pxy  = Qak22Context.getProxy(destActorName);
            if( pxy == null ) {
                ColorsOut.outerr("Perhaps no setActorAsRemote for " + destActorName );
                return;
            }
            pxy.sendMsgOnConnection( msg.toString()) ; //NON Attende risposta  
        }
    }


La :blue:`registrazione` dell'interesse di un attore per un evento viene realizzata 
da una operazione di Qak22Context.

----------------------------------------
Qak22Context.registerAsEventObserver
----------------------------------------

.. code:: Java

    public class Qak22Context { 
        ...
        public static final String registerForEvent   = "registerForEvent";
        public static final String unregisterForEvent = "unregisterForEvent";

        public static void registerAsEventObserver(String observer, String evId) {
            QakActor22 a = getActor(EventMsgHandler.myName);
            if( a == null ) new EventMsgHandler();
            IApplMessage m = CommUtils.buildDispatch(observer,
                                registerForEvent, evId, EventMsgHandler.myName);
            Qak22Util.sendAMsg( m, EventMsgHandler.myName ); 
        }

    }

------------------------------
gestione di un evento
------------------------------

La gestione di un evento 

.. code:: Java
  
  protected static HashMap<String,String> eventObserverMap = new HashMap<String,String>();  

  protected void handleEvent(IApplMessage msg) {
    try {
    if( msg.msgId().equals(Qak22Context.registerForEvent)) {
      eventObserverMap.put(msg.msgSender(), msg.msgContent());
    }else if( msg.isEvent()) {
      eventObserverMap.forEach( ( actorName,  evName) -> {
            if( evName.equals(msg.msgId()) ) {
              sendMsg( msg  );
            }
      } ) ;
    }else ColorsOut.outerr( "QakActor22 handleEvent: msg unknown");
		}catch( Exception e) {...	}
	}    