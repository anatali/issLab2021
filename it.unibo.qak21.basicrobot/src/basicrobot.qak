/* 
 * ================================================================================
 * basicrobot.qak
 * VERSION July 8, 2021
 * The basicrobot emits the event  obstacle : obstacle(ID)
 * 
 * External MQTT sites:
 * 	"mqtt.eclipse.org:  mosquitto.org mqtt.fluux.io  broker.hivemq.com
 * ================================================================================
 */ 
  
System  /* -trace */ basicrobot          
//mqttBroker "localhost" : 1883 eventTopic "unibo/basicrobot"   		

Dispatch cmd       	: cmd(MOVE)     
Dispatch end       	: end(ARG)  
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
  
Dispatch obstacle  : obstacle( ARG ) 		//generated by distancefilter
Event  endall	   : endall( ARG )   
Event   info       : info( ARG ) 	    	//for external components, not coap-observed
Event  sonar       : sonar(DISTANCE,NAME)	//emitted by distancefilter
Event  obstacle    : obstacle( ARG ) 		//generated by handleObstacle
 
Context ctxbasicrobot ip [host="localhost" port=8020]  

CodedQActor datacleaner    context ctxbasicrobot className "rx.dataCleaner"
CodedQActor distancefilter context ctxbasicrobot className "rx.distanceFilter"
 
QActor basicrobot context ctxbasicrobot{
[#
  var StepTime      = 0L 
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "moveUnknown"
#]  
 	State s0 initial { 	      
 		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
        if[# RobotType != "virtual" #]{
	 		println("basicrobot | type=$RobotType attempts to activate the sonar pipe")	
	 		[#  //For real robots
			    //delay( 1500 ) //give to the realsonar the time to start
	 			var robotsonar = context!!.hasActor("realsonar")  
	 			if( robotsonar != null ){ 
	 				println("basicrobot | WORKING WITH SONARS") 
	 				//ACTIVATE THE DATA SOURCE realsonar
	 				forward("sonarstart", "sonarstart(1)" ,"realsonar" ) 				
	 				//SET THE PIPE  
	 				robotsonar.
	 				subscribeLocalActor("datacleaner").
	 				subscribeLocalActor("distancefilter").
	 				subscribeLocalActor("basicrobot")		//in order to perceive obstacle
	 			}else{
	 				println("basicrobot | WARNING: realsonar NOT FOUND")
	 			}
	 		#]  
 		} 
 		else{ //virtual
 			[#  var robotsonar = context!!.hasActor("robotsonar") 
	 			if( robotsonar != null ){ 
	 				println("basicrobot | WORKING WITH VIRTUAL SONAR") 
	 				//ACTIVATE THE DATA SOURCE realsonar
	 				forward("sonarstart", "sonarstart(1)" ,"robotsonar" ) 				
	 				//SET THE PIPE  
	 				robotsonar.
	 				subscribeLocalActor("datacleaner").
	 				subscribeLocalActor("distancefilter").
	 				subscribeLocalActor("basicrobot")		//in order to perceive obstacle
	 			}else{
	 				println("basicrobot | WARNING: realsonar NOT FOUND")
	 			}

 			#]
 		}
 		//updateResource [# "basicrobot(start)" #]
    	run unibo.robot.robotSupport.move( "h" )
 		delay 1000
   		run unibo.robot.robotSupport.move( "l" )
		run unibo.robot.robotSupport.move( "r" )
 		discardMsg Off  //WE want receive any msg
 	}
	Goto work
	
	State work{ 
		println("basicrobot  | waiting .................. ")  
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep			
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors  
			run unibo.robot.robotSupport.move( "${payloadArg(0)}" )
			[# CurrentMove =  "${payloadArg(0)}" #] 
			if [# CurrentMove != "h" #] { updateResource [# "moveactivated($CurrentMove)" #] }
		}
	 }
	 Goto work  
	 
	State handleObstacle{   
	    run unibo.robot.robotSupport.move( "h" )
		println("basicrobot | handleObstacleeeeeeeeeeeeeeeeeeee CurrentMove=$CurrentMove")	
		printCurrentMessage
			//msg(obstacle,dispatch,distancefilter,basicrobot,obstacle(5),18)
		if[# CurrentMove == "w" #]{
			run unibo.robot.robotSupport.move( "h" )   
 			run unibo.robot.robotSupport.move( "s" ) 
			delay 100 //loose the control ...
			run unibo.robot.robotSupport.move( "h" ) 
			delay 200	 		    	
			/*
			 * collision Json      : emitted by the virtualrobot 
			 * obstacle(virtual)   : emitted by the virtualrobotSupport2021 when endmove=false
			 * obstacle(5)         : emitted by the distanceFilter
			 * obstacle(w)         : emitted by the basicrobot
			 */
			onMsg( obstacle : obstacle( T ) ){ 
				[#	val TargetObs = payloadArg(0)  	#]
				if[# TargetObs == "5" #]{
					updateResource [# "obstacle(w)" #]
				}
			} 
		}else{ //CurrentMove != "w"
			updateResource [# "spurious" #]
		}  		
	}
	Goto work 
 
    State backstep{
		    delay 1500 //give time to the tester to manage the update
		    println("basicrobot | bakkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk")	
			run unibo.robot.robotSupport.move( "s" ) 
			delay 100 //loose the control ...
			run unibo.robot.robotSupport.move( "h" ) 			    	
    }
    Goto work 
    
	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone //stepPerhapsDone	//caused by p
		whenMsg  obstacle     -> stepFail		
        //whenMsg     cmd       -> execcmd
  	 
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done
		println("basicrobot | stepDone")
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		//println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  		
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;  
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		onMsg( end : end( V ) ){ 
			println("basicrobot | endwork")
			updateResource [# "basicrobot(end)" #]	 		
			//run utils.virtualRobotSupportQak.terminatevr( )
		}
 		emit endall : endall(normal) 
 		terminate 1
	}   
 }

QActor envsonarhandler context ctxbasicrobot{
 	State s0 initial { 	 
 		println("envsonarhandler | START")	 		
	}	
	Transition t1   whenEvent sonar -> handleEnvSonar
	
	State handleEnvSonar{
		printCurrentMessage
		/* 
		onMsg( sonar : sonar(D,T)){ 
			println("envsonarhandler | sonar(${payloadArg(0)}) ")
		}*/
	}
	Transition t1 whenEvent sonar -> handleEnvSonar  
}

/* 
 * 
//Just to test that the event is emitted ...
QActor perceiver context ctxbasicrobot{
 	State s0 initial { 	 
 		println("perceiver | START")	 		
	}	
	Transition t1   whenEvent polar-> handlePolar
 
  State handlePolar{
  	printCurrentMessage
  }
  Goto s0
}
* */